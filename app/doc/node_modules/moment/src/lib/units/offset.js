"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cloneWithOffset = cloneWithOffset;
exports.getSetOffset = getSetOffset;
exports.getSetZone = getSetZone;
exports.setOffsetToUTC = setOffsetToUTC;
exports.setOffsetToLocal = setOffsetToLocal;
exports.setOffsetToParsedOffset = setOffsetToParsedOffset;
exports.hasAlignedHourOffset = hasAlignedHourOffset;
exports.isDaylightSavingTime = isDaylightSavingTime;
exports.isDaylightSavingTimeShifted = isDaylightSavingTimeShifted;
exports.isLocal = isLocal;
exports.isUtcOffset = isUtcOffset;
exports.isUtc = isUtc;

var _zeroFill = _interopRequireDefault(require("../utils/zero-fill"));

var _create = require("../duration/create");

var _addSubtract = require("../moment/add-subtract");

var _constructor = require("../moment/constructor");

var _format = require("../format/format");

var _regex = require("../parse/regex");

var _token = require("../parse/token");

var _local = require("../create/local");

var _fromAnything = require("../create/from-anything");

var _utc = require("../create/utc");

var _isDate = _interopRequireDefault(require("../utils/is-date"));

var _toInt = _interopRequireDefault(require("../utils/to-int"));

var _isUndefined = _interopRequireDefault(require("../utils/is-undefined"));

var _compareArrays = _interopRequireDefault(require("../utils/compare-arrays"));

var _hooks = require("../utils/hooks");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

// FORMATTING
function offset(token, separator) {
  (0, _format.addFormatToken)(token, 0, 0, function () {
    var offset = this.utcOffset();
    var sign = '+';

    if (offset < 0) {
      offset = -offset;
      sign = '-';
    }

    return sign + (0, _zeroFill["default"])(~~(offset / 60), 2) + separator + (0, _zeroFill["default"])(~~offset % 60, 2);
  });
}

offset('Z', ':');
offset('ZZ', ''); // PARSING

(0, _regex.addRegexToken)('Z', _regex.matchShortOffset);
(0, _regex.addRegexToken)('ZZ', _regex.matchShortOffset);
(0, _token.addParseToken)(['Z', 'ZZ'], function (input, array, config) {
  config._useUTC = true;
  config._tzm = offsetFromString(_regex.matchShortOffset, input);
}); // HELPERS
// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']

var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
  var matches = (string || '').match(matcher);

  if (matches === null) {
    return null;
  }

  var chunk = matches[matches.length - 1] || [];
  var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
  var minutes = +(parts[1] * 60) + (0, _toInt["default"])(parts[2]);
  return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
} // Return a moment from input, that is local/utc/zone equivalent to model.


function cloneWithOffset(input, model) {
  var res, diff;

  if (model._isUTC) {
    res = model.clone();
    diff = ((0, _constructor.isMoment)(input) || (0, _isDate["default"])(input) ? input.valueOf() : (0, _local.createLocal)(input).valueOf()) - res.valueOf(); // Use low-level api, because this fn is low-level api.

    res._d.setTime(res._d.valueOf() + diff);

    _hooks.hooks.updateOffset(res, false);

    return res;
  } else {
    return (0, _local.createLocal)(input).local();
  }
}

function getDateOffset(m) {
  // On Firefox.24 Date#getTimezoneOffset returns a floating point.
  // https://github.com/moment/moment/pull/1871
  return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
} // HOOKS
// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.


_hooks.hooks.updateOffset = function () {}; // MOMENTS
// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.


function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset = this._offset || 0,
      localAdjust;

  if (!this.isValid()) {
    return input != null ? this : NaN;
  }

  if (input != null) {
    if (typeof input === 'string') {
      input = offsetFromString(_regex.matchShortOffset, input);

      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }

    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }

    this._offset = input;
    this._isUTC = true;

    if (localAdjust != null) {
      this.add(localAdjust, 'm');
    }

    if (offset !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        (0, _addSubtract.addSubtract)(this, (0, _create.createDuration)(input - offset, 'm'), 1, false);
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;

        _hooks.hooks.updateOffset(this, true);

        this._changeInProgress = null;
      }
    }

    return this;
  } else {
    return this._isUTC ? offset : getDateOffset(this);
  }
}

function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== 'string') {
      input = -input;
    }

    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}

function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;

    if (keepLocalTime) {
      this.subtract(getDateOffset(this), 'm');
    }
  }

  return this;
}

function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === 'string') {
    var tZone = offsetFromString(_regex.matchOffset, this._i);

    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }

  return this;
}

function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }

  input = input ? (0, _local.createLocal)(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}

function isDaylightSavingTimeShifted() {
  if (!(0, _isUndefined["default"])(this._isDSTShifted)) {
    return this._isDSTShifted;
  }

  var c = {};
  (0, _constructor.copyConfig)(c, this);
  c = (0, _fromAnything.prepareConfig)(c);

  if (c._a) {
    var other = c._isUTC ? (0, _utc.createUTC)(c._a) : (0, _local.createLocal)(c._a);
    this._isDSTShifted = this.isValid() && (0, _compareArrays["default"])(c._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }

  return this._isDSTShifted;
}

function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}

function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}